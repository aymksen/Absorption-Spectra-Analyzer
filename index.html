<!DOCTYPE html>
<html>
<head>
    <title>Absorption Spectra Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.0/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }
        #drop-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 50px;
            text-align: center;
            font-size: 1.2em;
            color: #555;
            cursor: pointer;
            background-color: #fff;
            transition: background-color 0.3s ease;
        }
        #drop-area.highlight {
            background-color: #e0e0e0;
        }
        #parameters {
            background-color: #fff;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-top: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        #parameters label {
            font-weight: bold;
            margin-right: 5px;
        }
        #parameters input[type="number"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 80px;
        }
        #applyParams {
            padding: 8px 15px;
            background-color: #28a745; /* Green color for apply */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }
        #applyParams:hover {
            background-color: #218838;
        }
        #chart-container {
            position: relative;
            height: 600px;
            width: 100%;
            margin-top: 30px;
            background-color: #fff;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        #resetZoom {
            margin-top: 10px;
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }
        #resetZoom:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

    <h1>Absorption Spectra Analyzer</h1>

    <div id="drop-area">
        <p>Drag and drop Excel (.xlsx, .xls) or CSV (.csv) files here, or click to select files.</p>
        <input type="file" id="fileElem" multiple accept=".xlsx, .xls, .csv" style="display: none;">
    </div>

    <div id="parameters">
        <div>
            <label for="windowLength">Window Length:</label>
            <input type="number" id="windowLength" value="11" min="3" step="2"> 
        </div>
        <div>
            <label for="polyOrder">Polynomial Order:</label>
            <input type="number" id="polyOrder" value="1" min="1" max="5">
        </div>
        <button id="applyParams">Apply Parameters</button>
    </div>

    <div id="chart-container">
        <canvas id="myChart"></canvas>
    </div>
    <button id="resetZoom">Reset Zoom</button>

    <script>
        const dropArea = document.getElementById('drop-area');
        const fileElem = document.getElementById('fileElem');
        const resetZoomButton = document.getElementById('resetZoom');
        const windowLengthInput = document.getElementById('windowLength');
        const polyOrderInput = document.getElementById('polyOrder');
        const applyParamsButton = document.getElementById('applyParams');
        let myChart;
        let loadedFilesData = []; // Store raw data of loaded files

        // Define specific colors for original and processed spectra
        const ORIGINAL_SPECTRUM_COLOR = 'rgba(54, 162, 235, 0.4)'; // Light Blue for original
        const PROCESSED_SPECTRUM_COLORS = [ // Various colors for processed spectra
            'rgba(255, 99, 132, 0.8)', // Red
            'rgba(255, 206, 86, 0.8)', // Yellow
            'rgba(75, 192, 192, 0.8)', // Green
            'rgba(153, 102, 255, 0.8)',// Purple
            'rgba(255, 159, 64, 0.8)', // Orange
            'rgba(199, 199, 199, 0.8)',// Grey
            'rgba(83, 102, 255, 0.8)', // Indigo
            'rgba(40, 159, 64, 0.8)',  // Dark Green
            'rgba(210, 240, 40, 0.8)'  // Lime Green
        ];

        // Highlight drop area when file is dragged over
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('highlight'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('highlight'), false);
        });

        // Handle dropped files
        dropArea.addEventListener('drop', handleDrop, false);

        // Handle click to select files
        dropArea.addEventListener('click', () => fileElem.click(), false);
        fileElem.addEventListener('change', (event) => loadAndProcessFiles(event.target.files), false);

        resetZoomButton.addEventListener('click', () => {
            if (myChart) {
                myChart.resetZoom();
            }
        });

        // Handle applying new parameters
        applyParamsButton.addEventListener('click', () => {
            if (loadedFilesData.length > 0) {
                // Re-process all loaded data with new parameters
                processAndRenderAllFiles();
            } else {
                alert("Please drop files first before applying parameters.");
            }
        });

        function preventDefaults (e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            let dt = e.dataTransfer;
            let files = dt.files;
            loadAndProcessFiles(files);
        }

        async function loadAndProcessFiles(files) {
            loadedFilesData = []; // Clear previous data
            
            for (const file of files) {
                const fileExtension = file.name.split('.').pop().toLowerCase();
                let wavelength = [];
                let intensity = [];
                let filenameWithoutExt = file.name.replace(/\.(xlsx|xls|csv)$/i, "");

                if (fileExtension === 'xlsx' || fileExtension === 'xls') {
                    const data = await readFileAsync(file, 'binary');
                    const workbook = XLSX.read(data, { type: 'binary' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    // Assuming first row is header, first column = wavelength, second column = intensity
                    wavelength = json.slice(1).map(row => parseFloat(row[0])).filter(val => !isNaN(val));
                    intensity = json.slice(1).map(row => parseFloat(row[1])).filter(val => !isNaN(val));

                } else if (fileExtension === 'csv') {
                    const text = await readFileAsync(file, 'text');
                    const lines = text.split('\n');
                    const dataRows = lines.filter(line => !line.startsWith('#') && line.trim() !== ''); // Filter comments and empty lines
                    
                    if (dataRows.length > 1) { // Check for header + at least one data row
                        const headers = dataRows[0].split(',').map(h => h.trim().toLowerCase());
                        const wavelengthColIndex = headers.indexOf('wavelength');
                        const intensityColIndex = headers.indexOf('intensity');

                        if (wavelengthColIndex === -1 || intensityColIndex === -1) {
                            alert(`CSV file ${file.name} must contain 'wavelength' and 'intensity' columns.`);
                            continue;
                        }

                        for (let i = 1; i < dataRows.length; i++) {
                            const values = dataRows[i].split(',');
                            const w = parseFloat(values[wavelengthColIndex]);
                            const int = parseFloat(values[intensityColIndex]);
                            if (!isNaN(w) && !isNaN(int)) {
                                wavelength.push(w);
                                intensity.push(int);
                            }
                        }
                    } else {
                        console.warn(`Skipping file ${file.name}: CSV file is empty or only contains comments.`);
                        continue; // Skip to next file
                    }
                } else {
                    console.warn(`Skipping file ${file.name}: Not a supported file type (.xlsx, .xls, .csv).`);
                    continue; // Skip to next file
                }

                if (wavelength.length > 0 && intensity.length > 0) {
                    loadedFilesData.push({
                        name: filenameWithoutExt,
                        wavelength: wavelength,
                        intensity: intensity
                    });
                } else {
                    console.warn(`Skipping file ${file.name}: No valid numeric data found.`);
                }
            }

            processAndRenderAllFiles();
        }

        function processAndRenderAllFiles() {
            const allDatasets = [];
            let colorIndex = 0; // Separate index for processed spectrum colors

            const windowLength = parseInt(windowLengthInput.value);
            const polyOrder = parseInt(polyOrderInput.value);

            // Basic validation for Savitzky-Golay parameters
            if (isNaN(windowLength) || windowLength < 3 || windowLength % 2 === 0) {
                alert("Window Length must be an odd number greater than or equal to 3.");
                return;
            }
            if (isNaN(polyOrder) || polyOrder < 1 || polyOrder >= windowLength) {
                alert("Polynomial Order must be an integer greater than or equal to 1, and less than Window Length.");
                return;
            }


            for (const fileData of loadedFilesData) {
                const { name, wavelength, intensity } = fileData;
                const processedData = processSpectrum(wavelength, intensity, windowLength, polyOrder);
                
                // Original data (always blue)
                allDatasets.push({
                    label: `${name} (Original)`,
                    data: intensity.map((val, i) => ({ x: wavelength[i], y: val })),
                    borderColor: ORIGINAL_SPECTRUM_COLOR,
                    backgroundColor: ORIGINAL_SPECTRUM_COLOR.replace('0.4)', '0.1)'),
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0,
                    yAxisID: 'y'
                });

                // Processed data (cycling through PROCESSED_SPECTRUM_COLORS)
                allDatasets.push({
                    label: `${name} (Absorbance)`,
                    data: processedData.map((val, i) => ({ x: wavelength[i], y: val })),
                    borderColor: PROCESSED_SPECTRUM_COLORS[colorIndex % PROCESSED_SPECTRUM_COLORS.length],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    yAxisID: 'y1'
                });
                colorIndex++;
            }

            if (allDatasets.length > 0) {
                renderChart(allDatasets);
            } else {
                // This case should ideally not be hit if loadedFilesData is empty when called
                // but kept for safety.
                alert("No valid data to process and display. Please load files.");
            }
        }

        function readFileAsync(file, type) {
            return new Promise((resolve, reject) => {
                let reader = new FileReader();
                reader.onload = () => {
                    resolve(reader.result);
                };
                reader.onerror = reject;
                if (type === 'binary') {
                    reader.readAsBinaryString(file);
                } else if (type === 'text') {
                    reader.readAsText(file);
                }
            });
        }

        // Updated savgol_filter to accept window_length and polyorder
        function savgol_filter(data, window_length, polyorder, deriv = 0) {
            // A simplified Savitzky-Golay filter for browser.
            // Note: This is a simple moving average. A true Savitzky-Golay filter 
            // implementation in pure JS is significantly more complex due to polynomial fitting.
            // The `polyorder` parameter is acknowledged but not fully implemented in this simplified version.
            // For true S-G, you'd need linear algebra for polynomial regression.

            // Ensure window_length is odd and not greater than data length
            if (window_length % 2 === 0) window_length += 1;
            if (window_length > data.length) window_length = data.length % 2 === 0 ? data.length - 1 : data.length;
            if (window_length < 3) window_length = 3; 
            
            // Check if polyOrder is valid (less than window_length)
            // if (polyorder >= window_length) {
            //     console.warn("Polynomial order must be less than window length. Adjusting polyorder to window_length - 1.");
            //     polyorder = window_length - 1;
            // }


            const half_window = Math.floor(window_length / 2);
            const smoothed_data = Array(data.length).fill(0);

            for (let i = 0; i < data.length; i++) {
                let sum = 0;
                let count = 0;
                for (let j = -half_window; j <= half_window; j++) {
                    if (i + j >= 0 && i + j < data.length) {
                        sum += data[i + j];
                        count++;
                    }
                }
                smoothed_data[i] = sum / count;
            }
            return smoothed_data;
        }

        // Updated processSpectrum to accept window_length and polyorder
        function processSpectrum(wavelength, intensity, window_length, polyorder) {
            const numericIntensity = intensity.map(Number);

            const smoothed = savgol_filter(numericIntensity, window_length, polyorder); // Pass params
            const baseline_corrected = smoothed.map(val => val - Math.min(...smoothed));

            const derivative = baseline_corrected.map((val, i, arr) => {
                if (i === 0) return 0;
                return val - arr[i - 1];
            });

            const minDerivative = Math.min(...derivative);
            const maxDerivative = Math.max(...derivative);

            const normalized = derivative.map(val =>
                maxDerivative - minDerivative === 0 ? 0 : (val - minDerivative) / (maxDerivative - minDerivative)
            );

            const absorption = normalized.map(val => -Math.log10(Math.max(val, 1e-6)));

            return absorption;
        }

        function renderChart(datasets) {
            const ctx = document.getElementById('myChart').getContext('2d');

            if (myChart) {
                myChart.destroy(); // Destroy previous chart instance
            }

            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Absorption Spectra of Different Materials',
                            font: {
                                size: 18
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top',
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy',
                            },
                            pan: { // Enable panning
                                enabled: true,
                                mode: 'xy',
                                modifierKey: 'shift', // Hold Shift to pan, or remove for always-on pan
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Wavelength (nm)'
                            }
                        },
                        y: { // Y-axis for Original Intensity
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Intensity (a.u.)'
                            }
                        },
                        y1: { // Separate Y-axis for Absorbance
                            type: 'linear',
                            position: 'right', // Place on the right side
                            title: {
                                display: true,
                                text: 'Absorbance (a.u.)'
                            },
                            grid: {
                                drawOnChartArea: false, // Only draw grid lines for the left Y-axis
                            },
                            ticks: {
                                callback: function(value, index, ticks) {
                                    return value.toFixed(2); // Format absorbance ticks
                                }
                            }
                        }
                    }
                }
            });
        }
    </script>

</body>
</html>